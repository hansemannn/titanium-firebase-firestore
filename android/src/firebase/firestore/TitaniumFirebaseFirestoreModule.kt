/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * TiDev Titanium Mobile
 * Copyright TiDev, Inc. 04/07/2022-Present
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */

package firebase.firestore

import com.google.firebase.Timestamp
import com.google.firebase.firestore.ktx.firestore
import com.google.firebase.ktx.Firebase
import org.appcelerator.kroll.KrollDict
import org.appcelerator.kroll.KrollFunction
import org.appcelerator.kroll.KrollModule
import org.appcelerator.kroll.annotations.Kroll
import org.appcelerator.kroll.common.Log
import org.appcelerator.titanium.util.TiConvert


@Kroll.module(name = "TitaniumFirebaseFirestore", id = "firebase.firestore")
class TitaniumFirebaseFirestoreModule : KrollModule() {

    // Methods

    @Kroll.method
    fun addDocument(params: KrollDict) {
        val callback = params["callback"] as KrollFunction
        val collection = params["collection"] as String
        var document = ""
        if (params.containsKeyAndNotNull("document")) {
            document = params["document"] as String
        }
        var subcollection = ""
        if (params.containsKeyAndNotNull("subcollection")) {
            subcollection = params["subcollection"] as String
        }

        val data = params.getKrollDict("data")
        if (document.isEmpty()) {
            // auto-id document
            var fireCollection = Firebase.firestore.collection(collection)

            if (subcollection != "") {
                fireCollection = fireCollection.document().collection(subcollection)
            }

            fireCollection.add(data)
                .addOnSuccessListener {
                    val event = KrollDict()
                    event["success"] = true
                    event["documentID"] = it.id
                    event["document"] =  FirebaseDocumentProxy(it, it.id, collection)
                    callback.callAsync(getKrollObject(), event)

                }
                .addOnFailureListener { error ->
                    val event = KrollDict()
                    event["success"] = false
                    event["error"] = error.localizedMessage

                    callback.callAsync(getKrollObject(), event)
                }
        } else {
            // fixed document
            var fireCollection = Firebase.firestore.collection(collection)
                .document(document)

            if (subcollection != "") {
                fireCollection = fireCollection.collection(subcollection).document()
            }

            fireCollection.set(data)
                .addOnSuccessListener {
                    val event = KrollDict()
                    event["success"] = true
                    event["documentID"] = document

                    callback.callAsync(getKrollObject(), event)
                }
                .addOnFailureListener { error ->
                    val event = KrollDict()
                    event["success"] = false
                    event["error"] = error.localizedMessage

                    callback.callAsync(getKrollObject(), event)
                }
        }
    }

    private fun addListener(params: KrollDict) {
        val collection = params["collection"] as String
        val document = TiConvert.toString(params["document"], "")
        val subcollection = TiConvert.toString(params["subcollection"], "")

        var fireCollection = Firebase.firestore.collection(collection)
        if (subcollection != "" && document != "") {
            fireCollection = Firebase.firestore.collection(collection).document(document)
                .collection(subcollection)
        }

        fireCollection.addSnapshotListener { value, e ->
            if (e != null) {
                return@addSnapshotListener
            }

            if (value != null) {

                val kd = KrollDict()
                val kdItems = arrayOfNulls<Any>(value.documentChanges.size)
                var i:Int = 0

                value.documentChanges.forEach { item ->
                    val d = KrollDict()
                    val doc = KrollDict()
                    item.document.data.toMap().forEach {
                        d[it.key] = it.value
                    }
                    doc["document"] = item.document.id
                    doc["items"] = d;
                    kdItems[i] = doc
                    i++
                }

                kd["documents"] = kdItems
                kd["collection"] = collection
                fireEvent("change", kd)
            }
        }
    }

    @Kroll.method
    fun getDocuments(params: KrollDict) {
        val callback = params["callback"] as KrollFunction
        val collection = params["collection"] as String
        val document = TiConvert.toString(params["document"], "")
        val subcollection = TiConvert.toString(params["subcollection"], "")

        var fireCollection = Firebase.firestore.collection(collection)
        if (subcollection != "" && document != "") {
            fireCollection = Firebase.firestore.collection(collection).document(document)
                .collection(subcollection)
        }

        if (TiConvert.toBoolean(params["addListeners"],false)) {
            addListener(params);
        }

        fireCollection
            .get()
            .addOnSuccessListener { it ->

                val list = mutableListOf<Map<String, Any>>()
                for (documentRef in it.documents) {
                    val d = KrollDict()
                    Log.i("---", "ID: " + documentRef.id+ "->"+ documentRef.reference);
                    documentRef.data!!.toMap().forEach {
                        if ((it.value is Timestamp)) {
                            val ts: Timestamp = it.value as Timestamp
                            d[it.key] = ts.seconds
                        } else {
                            d[it.key] = it.value
                        }
                    }
                    // d["document"] = FirebaseDocumentProxy(documentRef.reference, documentRef.id, collection);
                    d["_id"] = documentRef.id
                    list.add(d)
                }

                val event = KrollDict()
                event["success"] = true
                event["documents"] = list.toTypedArray()

                callback.callAsync(getKrollObject(), event)
            }
            .addOnFailureListener { error ->
                val event = KrollDict()
                event["success"] = false
                event["error"] = error.localizedMessage

                callback.callAsync(getKrollObject(), event)
            }
    }

    @Kroll.method
    fun getDocument(params: KrollDict): FirebaseDocumentProxy? {
        //val callback = params["callback"] as KrollFunction
        val collection = params["collection"] as String
        val document = TiConvert.toString(params["document"], "")
        if (document.isEmpty()) {
            return null
        }
        val docRef = Firebase.firestore.collection(collection).document(document)
        return FirebaseDocumentProxy(docRef, document, collection)
    }

    @Kroll.method
    fun updateDocument(params: KrollDict) {
        Log.i("Firestore", "Deprecated. Please use the new Document syntax")
        val callback = params["callback"] as KrollFunction
        val collection = params["collection"] as String
        val data = params.getKrollDict("data")
        val document = params["document"] as String
        val subcollection = params["subcollection"] as String
        val subdocument = params["subdocument"] as String

        var fireCollection = Firebase.firestore.collection(collection)

        if (subcollection.isNotEmpty()) {
            fireCollection = fireCollection.document(subdocument).collection(subcollection)
        }

        fireCollection.document(document)
            .update(data)
            .addOnSuccessListener {
                val event = KrollDict()
                event["success"] = true

                callback.callAsync(getKrollObject(), event)
            }
            .addOnFailureListener { error ->
                val event = KrollDict()
                event["success"] = false
                event["error"] = error.localizedMessage

                callback.callAsync(getKrollObject(), event)
            }
    }

    @Kroll.method
    fun deleteDocument(params: KrollDict) {
        Log.i("Firestore", "Deprecated. Please use the new Document syntax")
        val callback = params["callback"] as KrollFunction
        val collection = params["collection"] as String
        val document = params["document"] as String
        val subcollection = params["subcollection"] as String
        val subDocument = params["subdocument"] as String

        var fireCollection = Firebase.firestore.collection(collection).document(document)

        if (subcollection != "" && subDocument != "") {
            fireCollection = Firebase.firestore.collection(collection).document(subDocument)
                .collection(subcollection).document(document)
        }

        fireCollection.delete()
            .addOnSuccessListener {
                val event = KrollDict()
                event["success"] = true

                callback.callAsync(getKrollObject(), event)
            }
            .addOnFailureListener { error ->
                val event = KrollDict()
                event["success"] = false
                event["error"] = error.localizedMessage

                callback.callAsync(getKrollObject(), event)
            }
    }
}
